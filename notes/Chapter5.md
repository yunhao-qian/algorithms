# 5. 字符串

### 5.0.1 游戏规则

* 字符：`char`，16位。
* `String`不可变。
* `charAt()`在常数时间内完成。
* `length()`在常数时间内完成。
  > 有些情况下字符串的长度不能在常数时间内获得，如C语言的`strlen()`。
* `substring()`在常数时间内完成。
  > 在Java 7以前，子字符串和原字符串共享`char[]`数据，只是有不同的偏移量。
  > 从Java 7开始，`substring()`拷贝生成一个新的字符串，所需的时间和字符数量成正比。
* 字符串连接（`+`）所需的时间和结果字符串的长度成正比。
  > 如果要将字符一个一个地追加到字符串中，使用`StringBuilder`类，否则所需的时间是平方级别的。
* 字符数组：很多算法处理`char[]`或者`String`的代码的差别很小。
  > 转换：`String.toCharArray()`和`new String(char[] charArray)`。

### 5.0.2 字母表

`Alphabet`类：对字符串的字母表作出限制。

方法：
* `char toChar(int)`和`int toIndex(char)`：常数时间内在字符和索引之间进行转换。
* `R()`：字母表中的字符数量。
* `lgR()`：一个索引需要的bit数。

通过使用`Alphabet`类，我们限制了不同字符的个数，提高了算法的效率。
* 字符索引数组。
  > 计算一个字符串中每一个字符出现的次数。
  > 如果不知道字符范围，需要用字典或者大小为65536的数组。
  > 如果知道字符范围，可以用一个长度为`R`的数组。
* 数字。
  > 把一个`String`转换为一个`R`进制的数字（用`int[]`来表示），来简化代码。
  > 本书中`R = 256`。

## 5.1 字符串排序

两种字符串排序方法：
* 低位优先（LSD = Least-Significant-Digit First）。
  > 从右到左检查字符。适合用于键长相同的字符串。
* 高位优先（MSD）：
  > 从左到右检查字符。把字符数组切分成子数组，递归地完成排序。
> Digit：把一个字符串看作一个256进制的数字。

### 5.1.1 键索引计数法

适合键是很小的整数的情况。每一个字符串有一个键，我们将它们根据键从小到大分类。

* 频率统计：在`count[]`数组中记录每个键出现的次数。
  > 将`count`的头一个元素留空为0。如果键是`i`，那么在第`i + 1`个元素计数。
  > 留空头一个元素的目的是方便下一步的操作。
* 将频率转化为索引。
  > 原先，`count[i + 1]`保存的是键`i`出现的次数。
  > 转化后，`count[i]`保存的是键为`i`的字符串的起始索引。
* 数据分类。
  > 把字符串数组在`aux[]`里异地排序。键相同的元素相对位置没有变化。
  > 在放置一个键为`i`的字符串后，`count[i]`增加1。
* 回写：把`aux[]`复制回原数组中。

复杂度分析（原数组长度是$N$，键的范围是$0$到$R - 1$）：
* 初始化数组：
  `count[]`长度为$R + 1$；`aux[]`长度为$N$。共$N + R + 1$次。
* 频率统计：
  访问原数组和`count[]`各$N$次，共$2N$次。
* 将频率转化为索引：
  `count[i + 1] += count[i]`，每一次增加访问2次。共$2R$次。
* 数据分类：
  每一次移动，访问原数组1次，`aux[]`一次，`count[]`一次。共$3N$次。
* 回写：
  访问原数组和`aux[]`各$N$次。共$2N$次。
* 总计：$8N + 3R + 1$次。

键索引计数法是一个线性时间级别的排序方法。
* 因为$R$很小，而且键索引计数法不是基于比较的排序方法，它突破了$N \log N$的运行时间下限。

### 5.1.2 低位优先的字符串排序

所有的字符串长度都是相同的（为$W$）。
从右向左以每个位置的字符作为键，用键索引记数法将字符串排序$W$遍。

命题：
在以第$i$个字符为键排序后，任意两个键在数组中的顺序都是正确的。排序依据是从第$i$到第$R - 1$的子字符串。

这个命题对于$i = R - 1$显然成立。下面用数学归纳法证明，命题对所有$0 \leq i < R$成立。

如果命题对$i = k + 1$成立，那么对于两个字符串：
* 如果它们的第$k$个字符不同，那么排序已经将它们的位置摆放正确。
* 如果它们的第$k$个字符相同，因为键索引计数法是稳定的，它们的位置关系在排序中没有改变。
  由于命题对于$k + 1$成立，因此它们的位置关系仍然正确。
* 所以，命题对于$i = k$也成立。

因为命题对于$i = 0$成立，所以LSD能够稳定地排序定长字符串。

时间复杂度（字符串长度为$W$，数组长度为$N$）：
* 只在最开始初始化`aux[]`，访问$N$次。
* 其他步骤在$W$次循环中的每一轮都会重复。每一轮中访问$7N + 3R + 1$次，共访问$7WN + 3WR + W$次。
* 总计：$7WN + 3WR + W + N$次。

空间复杂度：
* `aux[]`长度是$N$。
* `count[]`长度是$R + 1$。
* 总计：$N + R + 1$。

典型应用中，$R$很小而$N$很大，所以可以认为算法的运行时间和$WN$成正比。
因为$W$是每个字符串的字符数而$N$是字符串的数量，所以说运行时间和输入的规模（总字符数）成正比。

### 5.1.3 高位优先的字符串排序

* 递归地从左向右遍历所有字符。
* 先按照首字母排序，对每一个首字母切分出对应的子数组。
* 在每一个子数组中，按照下一个字母排序。

如何处理字符串末尾：
* 我们希望已经到达末尾的字符串可以在子数组中排到最前面，~~这样在下一轮递归排序时就可以忽略它。~~
* 使用一个私有的`charAt()`，在索引到达字符串末尾的时候不报错，而是返回-1（比任何其他char code都要小）。
  > 如果是在C或者C++中使用ASCII字符，字符串末尾的字符是`'\0'`，那么就不需要做这两步的特殊处理。
* 为了使-1在`count[]`数组中有非负索引，在`count[]`中字符使用的实际索引是它们的char code加1。
  > 因为键索引计数法本来就要在`count[]`中预留一个位置，`count[]`创建的长度是$R + 2$。

指定的字母表：
* 最高位优先的字符串排序来说，减少字母表中的字符数量可以带来很大的性能提升。
* 例如：只接受小写字母。

小型子数组：
* 在高位优先的字符串排序的每一次递归中，都会重新创建`count[]`数组。
* 如果$R$很大（如Unicode），那么反复创建`count[]`带来的代价非常高
* 所以，必须把小数组切换到插入排序。

等值键：
* 如果相同的子字符串出现的很多，那么插入排序就不会被触发，程序会递归地检查每一个字符。
* 含有大量前缀相同的键也会产生类似的性能问题。

额外空间：
* `aux[]`可以在递归方法以外创建。
* `count[]`必须要递归地多次创建，因此它需要的空间是主要问题。

性能：
* 对于随机输入，排序算法只会检查足以排序字符串所需的字符。
  相对于输入的字符（不是字符串）总数，运行时间是亚线性的。
* 对于非随机输入，最坏情况下（即所有字符串均相同），排序算法会检查键中的所有字符。
  相对于输入的字符总数，运行时间是线性的（和LSD相同）。

访问的字符数：
* 随机字符串模型：每个字符串都独立地由随机字符组成，长度没有限制。
* 在这个前提下，高位优先的字符串排序平均需要检查$N \log_R N$个字符。
  > 检查的字符个数和键的长度无关（因为允许的键长接近无穷）。

访问数组的次数：
* 最好情况下，只需要一轮键索引计数法即可完成排序，约$8N + 3R$次。
* 最坏情况下，性能和低位优先的字符串排序类似，约$\sim 7wN + 3wR$次（$w$是字符串的平均长度）。

空间（只考虑`count[]`）：
* `count[]`必须在递归中创建，而递归的深度是最长字符串的长度。
* 每轮递归使用的空间（即`count[]`的长度）是$R$。
* 所以，空间需求的总量和$R$乘最长字符串的长度之积成正比。

考虑切换插入排序的情况。假设在数组长度小于$M$时切换到插入排序，有$N / M$个长度为$M$的子数组：
* 如果切换插入排序：每个子数组插入排序平均需要$M^2 / 4$次比较，所以总共需要$MN / 4$次比较。
* 如果没有切换：因为每个子数组长度较小，$R$是主要因子，访问次数和$R$成正比。总共需要$NR / M$次访问。
* 用$MN / 4$次比较来换取$NR / M$次访问，可以看出$M$的取值应和$R$的平方根成正比。

### 5.1.4 三向字符串快速排序

改进版的快速排序：
* 选取一个pivot（如第一个元素），根据它的首字母进行三向切分。
  > 即根据字符串的首字母小于，等于，或大于pivot的首字母，分离出三个字数组。
* 对中间一个子数组，根据下一个字符进行三向切分。
  > 如果切分字符是-1，即已经到达了pivot字符串的末尾，那么停止递归。
* 对首尾两个子数组，再次根据首字母进行三向切分。

优点：
* 高位优先的字符串排序可能会创建大量（空）子数组，而三项字符串快速排序每次只有三个。
* 适应键的不同部分的不同结构（例如网址的公共前缀）。
* 原地排序，不需要额外的空间。

随机化：
* 可以打乱数组，或把第一个元素和一个随机位置的元素交换，以得到一个随机的pivot。
* 在标准的快速排序中，`compareTo()`总是从字符串开头开始比较，直到遇到不同的字母。这个比较是可以避免的。
* 三向字符串快速排序的优点是：在比较两个字符串时可以跳过它们已知的公共前缀。

时间复杂度（字符串长度为$W$，数组长度为$N$。假设字符串比较需要遍历整个字符串，即有很长的公共前缀）：
* 普通快速排序：$2WN \ln N$个字符。
  > 每次比较，读取的字符数和字符串长度$W$成正比。
  > 最多比较$2N \ln N$次。
* 三向字符串排序：$WN + 2N \ln N$个字符。
  > 发现所有的公共首字母：读取$WN$个字符。
  > 对剩下来的不同部分进行排序：比较$2N \ln N$次（因为公共部分很长，认为剩余的长度为常数项）。
* ~~三向字符串排序比较的字符数最多比普通快速排序少$2N \ln N$个。~~

### 5.1.5 字符串排序算法的选择

三项字符串排序是通用排序算法：
* 尤其适合于非随机字符串（含有较长公共前缀）。
* 三向字符串排序的性能不直接取决于字母表的大小。
* 然而，三向字符串排序是不稳定的，因为它基于快速排序。